# *****************************************************
# Project Type	: Console Application
# Project Name	: Реализация метода наименьших квадратов
# File Name	: laba3_Pyatygo_3.3.cpp
# Programmer(s) : Пятыго М.И.
# Created	: 13.11.2023
# Comments	:

# Замечания программиста: Функция с методом Гаусса была переписана с с++ на питон из лабораторной работы 1
# Обозначения используемых переменных в методе Гаусса не будет описана в графе обозначения, так как они есть в
# лабораторной работе 1

# Обозначения
# B1 и B2 - векторы коэффициентов матрицы для линейной и квадратичной функции соответственно
# C1 и C2 - векторы свободных коэффициентов матрицы для линейно и квадратичной функции
# N - количество точек
# P1, P2 - порядки для матриц
# x_0, y_0 - данные значения точек
# result1, result2 - вспомогательные переменные для записи результата
# m_error1, m_error2 - массив значений погрешностей для обоих функций

#  функция, считающая СЛАУ методом Гаусса из первой лабораторной с доработкой
import numpy as np                      # подключаем библиотеку для массивов
import matplotlib.pyplot as plt         # подключаем графику

def Gauss(B, C, P):
    t = []
    l = []
    x = [0] * P
    summ = 0
    arr = [B[i:i + P] for i in range(0, len(B), P)] # преобразуем вектор в матрицу (коэффициенты преобразуются слева
                                                # направо. При окончании столбца меняется строка, и продолжается запись)

    # Прямой ход
    for k in range(P):
        if arr[k][k] == 0:
            for m in range(P):
                l[m] = arr[k][m]
            t[k] = C[k]
            for j in range(P):
                arr[k][j] = arr[k + 1][j]
                arr[k + 1][j] = l[j]
            C[k] = C[k + 1]
            C[k + 1] = t[k]

        # непосредственно сам прямой ход

        for i in range(k + 1, P):
            d = arr[i][k] / arr[k][k]
            for j in range(k, P):
                arr[i][j] = arr[i][j] - d * arr[k][j]
            C[i] = C[i] - d * C[k]

    # обратный ход

    for k in range(P - 1, -1, -1):
        for i in range(k + 1, P):
            summ += arr[k][i] * x[i]
        if arr[k][k] != 0:
            x[k] = (C[k] - summ) / arr[k][k]
        else:
            x[k] = 0
    if P == 2:
        print("Приближающий многочлен первой степени:")
        print("F(x) ={:.3f}".format(x[0]), "x", "+{:.3f}".format(x[1]))
    elif P == 3:
        print("Приближающий многочлен второй степени:")
        print("F(x) ={:.3f}".format(x[0]), "x^2", "+{:.3f}".format(x[1]), "x", "+{:.3f}".format(x[2]))
    return x

# линейная функция
def lin_fun(a1):
    y = a1[0] * x + a1[1]
    return y
# квадратичная функция
def kv_fun(a1):
    y = a1[0] * pow(x, 2) + a1[1] * x + a1[0]
    return y

# функция, создающая график
def Graph(y1,y2,y3):
    fig, ax = plt.subplots()
    ax.set_title("График")      # Подписываем график
    ax.set_xlabel("x_0")        # Подписываем ось х
    ax.set_ylabel("y_0")        # Подписываем ось y
    ax.grid()
    ax.plot(x, y1)
    ax.plot(x, y2)
    ax.plot(x_0, y3, 'r--', marker='*')
    plt.show()

# main
N = 6
P1 = 2
P2 = 3
B1 = [0] * P1 * P1  # задаем нулевые векторы
B2 = [0] * P2 * P2
C1 = [0] * P1
C2 = [0] * P2
x_0 = [-0.9, 0.0, 0.9, 1.8, 2.7, 3.6]
y_0 = [-1.2689, 0.0, 1.2689, 2.6541, 4.4856, 9.9138]
y_0 = list(map(float, y_0))
result1 = [0]*P1
result2 = [0]*P2
m_error1 = [0] * N
m_error2 = [0] * N

# расчет

# вычисляем коэффициенты СЛАУ для линейной функции по формулам из учебника
for i in range(N):
    B1[0] = B1[0] + pow(x_0[i], 2)
    B1[1] = B1[1] + x_0[i]
    B1[2] = B1[1]
    C1[0] = C1[0] + y_0[i] * x_0[i]
    B1[3] = B1[3] + pow(x_0[i], 0)
    C1[1] = C1[1] + y_0[i]

result1 = Gauss(B=B1, C=C1, P=P1) # записываем вектор коэффициентов
result1 = list(map(float, result1)) # переписываем вектор в нужный тип

# вычисляем коэффициенты СЛАУ для квадратичной функции по формулам из учебника
for i in range(N):
    B2[0] = B2[0] + pow(x_0[i], 4)
    B2[1] = B2[1] + pow(x_0[i], 3)
    B2[3] = B2[1]
    B2[2] = B2[2] + pow(x_0[i], 2)
    B2[4] = B2[2]
    B2[5] = B2[5] + x_0[i]
    B2[6] = B2[4]
    B2[7] = B2[5]
    B2[8] = B2[8] + pow(x_0[i], 0)
    C2[0] = C2[0] + y_0[i] * pow(x_0[i], 2)
    C2[1] = C2[1] + y_0[i] * x_0[i]
    C2[2] = C2[2] + y_0[i]

print("Оранжевой сплошной линией показана квадратичная функция, синей - линейная, пунктирной красной - соединены "
      "точки x_ 0 и y_0 из дано")
result2 = Gauss(B=B2, C=C2, P=P2)
result2 = list(map(float, result2))
x = np.linspace(-2, 4)
x1 = np.array(range(-2, 4))
Graph(lin_fun(result1), kv_fun(result2), y_0)

# вычисляем погрешности
for i in range(N):
    if y_0[i] == 0:
        continue
    else:
        m_error1[i] = ((result1[0] * x_0[i] + result1[1]) - y_0[i]) / y_0[i]
        m_error2[i] = ((result2[0] * pow(x_0[i], 2) + result2[1] * x_0[i] + result2[0]) - y_0[i]) / y_0[i]

# выводим значения погрешностей
print("Величины погрешности для каждой точки по порядку для линейной функции: ")
for i in range(N):
    print(m_error1[i])
print("Величины погрешности для каждой точки по порядку для квадратичной функции: ")
for i in range(N):
    print(m_error2[i])
######################################################конец программы##################################################
#######################################################################################################################
